diff --git a/lib/basedriver/commands/session.js b/lib/basedriver/commands/session.js
index f1264e8..7be543a 100644
--- a/lib/basedriver/commands/session.js
+++ b/lib/basedriver/commands/session.js
@@ -4,10 +4,20 @@ import log from '../logger';
 import { errors } from '../../protocol';
 import { util } from 'appium-support';
 import { processCapabilities } from '../capabilities';
+import { executeShell } from '../mcloud-utils';
 
 let commands = {};
 
 commands.createSession = async function createSession (jsonwpDesiredCapabilities, jsonwpRequiredCaps, w3cCapabilities) {
+  log.debug(`[MCLOUD] resetting logs`);
+  const reset_log_command = `/opt/reset-logs.sh`;
+  executeShell(reset_log_command, '[MCLOUD] reset appium logs');
+
+  // TODO: test negative cases. Seems like we handled it correctly on session finish and during appium container termination
+  //  _logger.default.debug(`[MCLOUD] stopping capturing artifacts before session startup`);
+  //  const stop_rec_command = `/opt/stop-capture-artifacts.sh`;
+  //  (0, _mcloudUtils.executeShell)(stop_rec_command, '[MCLOUD] stop capturing artifacts before session startup');
+
   if (this.sessionId !== null) {
     throw new errors.SessionNotCreatedError('Cannot create a new session ' +
                                             'while one is in progress');
@@ -80,6 +90,13 @@ commands.createSession = async function createSession (jsonwpDesiredCapabilities
 
   log.info(`Session created with session id: ${this.sessionId}`);
 
+  log.debug(`[MCLOUD] Starting artifacts capturing for init steps`);
+  const start_rec_command = `/opt/start-capture-artifacts.sh ${this.sessionId} > /tmp/video.log 2>&1`;
+  executeShell(start_rec_command, '[MCLOUD] start artifacts capturing for init steps'); // 1 error code expected as process should be killed
+  
+  // save current sessionId globally to handle negative use-case instead of desired fallbackSessionId
+  process.env.sessionId = this.sessionId
+
   return [this.sessionId, caps];
 };
 
@@ -111,6 +128,19 @@ commands.deleteSession = async function deleteSession (/* sessionId */) {
       this.commandsQueueGuard.queues[key] = [];
     }
   }
+
+  // stop recording
+  log.debug(`[MCLOUD] stopping capturing artifacts for session ${this.sessionId}`);
+  const stop_rec_command = `/opt/stop-capture-artifacts.sh ${this.sessionId}`;
+  executeShell(stop_rec_command, '[MCLOUD] stop capturing artifacts');
+
+  await new Promise(resolve => setTimeout(resolve, 300));
+
+  // upload video
+  log.debug(`[MCLOUD] uploading captured artifacts`);
+  const upload_video_command = `/opt/upload-artifacts.sh ${this.sessionId} >> /tmp/video.log`;
+  executeShell(upload_video_command, '[MCLOUD] upload captured artifacts');
+
   this.sessionId = null;
 };
 
diff --git a/lib/basedriver/driver.js b/lib/basedriver/driver.js
index 867b861..8168c07 100644
--- a/lib/basedriver/driver.js
+++ b/lib/basedriver/driver.js
@@ -18,6 +18,7 @@ import {
 } from './image-element';
 import AsyncLock from 'async-lock';
 import { EventEmitter } from 'events';
+import { executeShell } from './mcloud-utils';
 
 
 B.config({
@@ -364,6 +365,12 @@ class BaseDriver extends Protocol {
     this._eventHistory.commands.push({cmd, startTime, endTime});
     if (cmd === 'createSession') {
       this.logEvent(EVENT_SESSION_START);
+
+      if(res != undefined && res.value != undefined) {
+        log.info(`[MCLOUD] starting artifacts capturing for session ${res.value[0]}`);
+        const start_rec_command = `/opt/start-capture-artifacts.sh ${res.value[0]} >> /tmp/video.log 2>&1`;
+        executeShell(start_rec_command, '[MCLOUD] start capturing artifacts'); // 1 error code expected as process should be killed
+      }
     } else if (cmd === 'deleteSession') {
       this.logEvent(EVENT_SESSION_QUIT_DONE);
     }
diff --git a/lib/basedriver/helpers.js b/lib/basedriver/helpers.js
index fcbf49d..8bdee52 100644
--- a/lib/basedriver/helpers.js
+++ b/lib/basedriver/helpers.js
@@ -6,6 +6,7 @@ import { tempDir, fs, util, zip, net, timing } from 'appium-support';
 import LRU from 'lru-cache';
 import AsyncLock from 'async-lock';
 import axios from 'axios';
+import { getLocalAppsFolder, getSharedFolderForAppUrl, getLocalFileForAppUrl, getFileContentLength } from './mcloud-utils';
 
 const IPA_EXT = '.ipa';
 const ZIP_EXTS = ['.zip', IPA_EXT];
@@ -68,7 +69,7 @@ async function retrieveHeaders (link) {
 
 function getCachedApplicationPath (link, currentAppProps = {}) {
   const refresh = () => {
-    logger.debug(`A fresh copy of the application is going to be downloaded from ${link}`);
+    logger.debug(`[MCLOUD] A fresh copy of the application is going to be downloaded from ${link}`);
     return null;
   };
 
@@ -133,6 +134,7 @@ async function configureApp (app, supportedAppExtensions) {
   let newApp = app;
   let shouldUnzipApp = false;
   let archiveHash = null;
+  let localAppsFolder;
   const remoteAppProps = {
     lastModified: null,
     immutable: false,
@@ -160,6 +162,84 @@ async function configureApp (app, supportedAppExtensions) {
         }
         logger.debug(`Cache-Control: ${headers['cache-control']}`);
       }
+
+      // ***** Custom logic for verification of local static path for APPs *****
+      let downloadIsNeaded = true;
+      localAppsFolder = await getLocalAppsFolder();
+      let localFile;
+      let lockFile;
+      const waitingTime = 1000;
+      const maxAttemptsCount = process.env.APPIUM_APP_WAITING_TIMEOUT;
+      
+      if(localAppsFolder != undefined) {
+        localFile = await getLocalFileForAppUrl(newApp);
+        lockFile = localFile + '.lock';
+
+        if(await fs.exists(localFile)) {
+          logger.info(`[MCLOUD] Local version of app was found. Will check actuality of the file`);
+          // Checking of local application actuality
+          const remoteFileLength = await getFileContentLength(app);
+          // At this point local file might be deleted by parallel session which updates outdated app
+          let attemptsCount = 0;
+          while(!await fs.exists(localFile) && (attemptsCount++ < maxAttemptsCount)) {
+            await new Promise((resolve) => {
+              logger.info(`[MCLOUD] Attempt #${attemptsCount} for local app file to appear again`);
+              setTimeout(resolve, waitingTime);
+            });
+          }
+          if(!await fs.exists(localFile)) {
+            throw Error(`[MCLOUD] Local application file has not appeared after updating by parallel Appium session`);
+          }
+          const stats = await fs.stat(localFile);
+          const localFileLength = stats.size;
+          logger.info(`[MCLOUD] Remote file size is ${remoteFileLength} and local file size is ${localFileLength}`);
+          if(remoteFileLength != localFileLength) {
+            logger.info(`[MCLOUD] Sizes differ. Hence that's needed to download fresh version of the app`);
+            await fs.unlink(localFile);
+            downloadIsNeaded = true;
+          } else {
+            logger.info(`[MCLOUD] Sizes are the same. Hence will use already stored application for the session`);
+            newApp = localFile;
+            shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));
+            downloadIsNeaded = false;
+          }
+        } else if (await fs.exists(lockFile)) {
+          logger.info(`[MCLOUD] Local version of app not found but .lock file exists. Waiting for .lock to disappear`);
+          // Wait for some time till App is downloaded by some parallel Appium instance
+          let attemptsCount = 0;
+          while(await fs.exists(lockFile) && (attemptsCount++ < maxAttemptsCount)) {
+            await new Promise((resolve) => {
+              logger.info(`[MCLOUD] Attempt #${attemptsCount} for .lock file checking`);
+              setTimeout(resolve, waitingTime);
+            });
+          }
+          if(await fs.exists(lockFile)) {
+            throw Error(`[MCLOUD] .lock file for downloading application has not disappeared after ${waitingTime * maxAttemptsCount}ms`);
+          }
+          if(!await fs.exists(localFile)) {
+            throw Error(`[MCLOUD] Local application file has not appeared after .lock file removal`);
+          }
+          logger.info(`[MCLOUD] Local version of app was found after .lock file removal. Will use it for new session`);
+          newApp = localFile;
+          shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));
+          downloadIsNeaded = false;
+        } else {
+          logger.info(`[MCLOUD] Neither local version of app nor .lock file was found. Will download app from remote URL.`);
+          downloadIsNeaded = true;
+        }
+      } else {
+        logger.info(`[MCLOUD] Local apps folder is not defined via environment properties, hence skipping this logic`);
+      }
+      if(downloadIsNeaded) {
+      
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] Local version of app was not found. Hence using default Appium logic for downloading`);
+          const sharedFolderPath = await getSharedFolderForAppUrl(app);
+          logger.info(`[MCLOUD] Folder for local shared apps: ${sharedFolderPath}`);
+          await fs.close(await fs.open(lockFile, 'w'));
+        }
+
+        try {
       const cachedPath = getCachedApplicationPath(app, remoteAppProps);
       if (cachedPath) {
         if (await fs.exists(cachedPath)) {
@@ -220,6 +300,20 @@ async function configureApp (app, supportedAppExtensions) {
         suffix: '',
       });
       newApp = await downloadApp(newApp, targetPath);
+
+      // ***** Custom logic for copying of downloaded app to static location *****
+      if(localAppsFolder != undefined) {
+        logger.info(`[MCLOUD] New app path: ${newApp}`);
+        await fs.copyFile(newApp, localFile);
+      }
+      }
+      finally {
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] Going to remove lock file ${lockFile}`)
+          await fs.unlink(lockFile);
+        }
+      }
+      }
     } else if (await fs.exists(newApp)) {
       // Use the local app
       logger.info(`Using local app '${newApp}'`);
@@ -240,7 +334,7 @@ async function configureApp (app, supportedAppExtensions) {
       if (APPLICATIONS_CACHE.has(app) && archiveHash === APPLICATIONS_CACHE.get(app).hash) {
         const {fullPath} = APPLICATIONS_CACHE.get(app);
         if (await fs.exists(fullPath)) {
-          if (archivePath !== app) {
+          if (archivePath !== app && localAppsFolder === undefined) {
             await fs.rimraf(archivePath);
           }
           logger.info(`Will reuse previously cached application at '${fullPath}'`);
@@ -253,7 +347,7 @@ async function configureApp (app, supportedAppExtensions) {
       try {
         newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);
       } finally {
-        if (newApp !== archivePath && archivePath !== app) {
+        if (newApp !== archivePath && archivePath !== app && localAppsFolder === undefined) {
           await fs.rimraf(archivePath);
         }
       }
diff --git a/lib/protocol/protocol.js b/lib/protocol/protocol.js
index fd457dc..361731b 100644
--- a/lib/protocol/protocol.js
+++ b/lib/protocol/protocol.js
@@ -357,6 +357,9 @@ function buildHandler (app, method, path, spec, driver, isSessCmd) {
         SESSIONS_CACHE.resetLogger(req.params.sessionId);
       }
     } catch (err) {
+      // PATCH #2 <appium>/node_modules/appium/node_modules/appium-base-driver/build/lib/protocol/protocol.js to return to carina "DEBUG info" about problematic step
+      err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+
       // if anything goes wrong, figure out what our response should be
       // based on the type of error that we encountered
       let actualErr = err;
diff --git a/lib/basedriver/commands/session.js b/lib/basedriver/commands/session.js
index f1264e8..7be543a 100644
--- a/lib/basedriver/commands/session.js
+++ b/lib/basedriver/commands/session.js
@@ -4,10 +4,20 @@ import log from '../logger';
 import { errors } from '../../protocol';
 import { util } from 'appium-support';
 import { processCapabilities } from '../capabilities';
+import { executeShell } from '../mcloud-utils';
 
 let commands = {};
 
 commands.createSession = async function createSession (jsonwpDesiredCapabilities, jsonwpRequiredCaps, w3cCapabilities) {
+  log.debug(`[MCLOUD] resetting logs`);
+  const reset_log_command = `/opt/reset-logs.sh`;
+  executeShell(reset_log_command, '[MCLOUD] reset appium logs');
+
+  // TODO: test negative cases. Seems like we handled it correctly on session finish and during appium container termination
+  //  _logger.default.debug(`[MCLOUD] stopping capturing artifacts before session startup`);
+  //  const stop_rec_command = `/opt/stop-capture-artifacts.sh`;
+  //  (0, _mcloudUtils.executeShell)(stop_rec_command, '[MCLOUD] stop capturing artifacts before session startup');
+
   if (this.sessionId !== null) {
     throw new errors.SessionNotCreatedError('Cannot create a new session ' +
                                             'while one is in progress');
@@ -80,6 +90,13 @@ commands.createSession = async function createSession (jsonwpDesiredCapabilities
 
   log.info(`Session created with session id: ${this.sessionId}`);
 
+  log.debug(`[MCLOUD] Starting artifacts capturing for init steps`);
+  const start_rec_command = `/opt/start-capture-artifacts.sh ${this.sessionId} > /tmp/video.log 2>&1`;
+  executeShell(start_rec_command, '[MCLOUD] start artifacts capturing for init steps'); // 1 error code expected as process should be killed
+  
+  // save current sessionId globally to handle negative use-case instead of desired fallbackSessionId
+  process.env.sessionId = this.sessionId
+
   return [this.sessionId, caps];
 };
 
@@ -111,6 +128,19 @@ commands.deleteSession = async function deleteSession (/* sessionId */) {
       this.commandsQueueGuard.queues[key] = [];
     }
   }
+
+  // stop recording
+  log.debug(`[MCLOUD] stopping capturing artifacts for session ${this.sessionId}`);
+  const stop_rec_command = `/opt/stop-capture-artifacts.sh ${this.sessionId}`;
+  executeShell(stop_rec_command, '[MCLOUD] stop capturing artifacts');
+
+  await new Promise(resolve => setTimeout(resolve, 300));
+
+  // upload video
+  log.debug(`[MCLOUD] uploading captured artifacts`);
+  const upload_video_command = `/opt/upload-artifacts.sh ${this.sessionId} >> /tmp/video.log`;
+  executeShell(upload_video_command, '[MCLOUD] upload captured artifacts');
+
   this.sessionId = null;
 };
 
diff --git a/lib/basedriver/driver.js b/lib/basedriver/driver.js
index 867b861..8168c07 100644
--- a/lib/basedriver/driver.js
+++ b/lib/basedriver/driver.js
@@ -18,6 +18,7 @@ import {
 } from './image-element';
 import AsyncLock from 'async-lock';
 import { EventEmitter } from 'events';
+import { executeShell } from './mcloud-utils';
 
 
 B.config({
@@ -364,6 +365,12 @@ class BaseDriver extends Protocol {
     this._eventHistory.commands.push({cmd, startTime, endTime});
     if (cmd === 'createSession') {
       this.logEvent(EVENT_SESSION_START);
+
+      if(res != undefined && res.value != undefined) {
+        log.info(`[MCLOUD] starting artifacts capturing for session ${res.value[0]}`);
+        const start_rec_command = `/opt/start-capture-artifacts.sh ${res.value[0]} >> /tmp/video.log 2>&1`;
+        executeShell(start_rec_command, '[MCLOUD] start capturing artifacts'); // 1 error code expected as process should be killed
+      }
     } else if (cmd === 'deleteSession') {
       this.logEvent(EVENT_SESSION_QUIT_DONE);
     }
diff --git a/lib/basedriver/helpers.js b/lib/basedriver/helpers.js
index fcbf49d..8bdee52 100644
--- a/lib/basedriver/helpers.js
+++ b/lib/basedriver/helpers.js
@@ -6,6 +6,7 @@ import { tempDir, fs, util, zip, net, timing } from 'appium-support';
 import LRU from 'lru-cache';
 import AsyncLock from 'async-lock';
 import axios from 'axios';
+import { getLocalAppsFolder, getSharedFolderForAppUrl, getLocalFileForAppUrl, getFileContentLength } from './mcloud-utils';
 
 const IPA_EXT = '.ipa';
 const ZIP_EXTS = ['.zip', IPA_EXT];
@@ -68,7 +69,7 @@ async function retrieveHeaders (link) {
 
 function getCachedApplicationPath (link, currentAppProps = {}) {
   const refresh = () => {
-    logger.debug(`A fresh copy of the application is going to be downloaded from ${link}`);
+    logger.debug(`[MCLOUD] A fresh copy of the application is going to be downloaded from ${link}`);
     return null;
   };
 
@@ -133,6 +134,7 @@ async function configureApp (app, supportedAppExtensions) {
   let newApp = app;
   let shouldUnzipApp = false;
   let archiveHash = null;
+  let localAppsFolder;
   const remoteAppProps = {
     lastModified: null,
     immutable: false,
@@ -160,6 +162,84 @@ async function configureApp (app, supportedAppExtensions) {
         }
         logger.debug(`Cache-Control: ${headers['cache-control']}`);
       }
+
+      // ***** Custom logic for verification of local static path for APPs *****
+      let downloadIsNeaded = true;
+      localAppsFolder = await getLocalAppsFolder();
+      let localFile;
+      let lockFile;
+      const waitingTime = 1000;
+      const maxAttemptsCount = process.env.APPIUM_APP_WAITING_TIMEOUT;
+      
+      if(localAppsFolder != undefined) {
+        localFile = await getLocalFileForAppUrl(newApp);
+        lockFile = localFile + '.lock';
+
+        if(await fs.exists(localFile)) {
+          logger.info(`[MCLOUD] Local version of app was found. Will check actuality of the file`);
+          // Checking of local application actuality
+          const remoteFileLength = await getFileContentLength(app);
+          // At this point local file might be deleted by parallel session which updates outdated app
+          let attemptsCount = 0;
+          while(!await fs.exists(localFile) && (attemptsCount++ < maxAttemptsCount)) {
+            await new Promise((resolve) => {
+              logger.info(`[MCLOUD] Attempt #${attemptsCount} for local app file to appear again`);
+              setTimeout(resolve, waitingTime);
+            });
+          }
+          if(!await fs.exists(localFile)) {
+            throw Error(`[MCLOUD] Local application file has not appeared after updating by parallel Appium session`);
+          }
+          const stats = await fs.stat(localFile);
+          const localFileLength = stats.size;
+          logger.info(`[MCLOUD] Remote file size is ${remoteFileLength} and local file size is ${localFileLength}`);
+          if(remoteFileLength != localFileLength) {
+            logger.info(`[MCLOUD] Sizes differ. Hence that's needed to download fresh version of the app`);
+            await fs.unlink(localFile);
+            downloadIsNeaded = true;
+          } else {
+            logger.info(`[MCLOUD] Sizes are the same. Hence will use already stored application for the session`);
+            newApp = localFile;
+            shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));
+            downloadIsNeaded = false;
+          }
+        } else if (await fs.exists(lockFile)) {
+          logger.info(`[MCLOUD] Local version of app not found but .lock file exists. Waiting for .lock to disappear`);
+          // Wait for some time till App is downloaded by some parallel Appium instance
+          let attemptsCount = 0;
+          while(await fs.exists(lockFile) && (attemptsCount++ < maxAttemptsCount)) {
+            await new Promise((resolve) => {
+              logger.info(`[MCLOUD] Attempt #${attemptsCount} for .lock file checking`);
+              setTimeout(resolve, waitingTime);
+            });
+          }
+          if(await fs.exists(lockFile)) {
+            throw Error(`[MCLOUD] .lock file for downloading application has not disappeared after ${waitingTime * maxAttemptsCount}ms`);
+          }
+          if(!await fs.exists(localFile)) {
+            throw Error(`[MCLOUD] Local application file has not appeared after .lock file removal`);
+          }
+          logger.info(`[MCLOUD] Local version of app was found after .lock file removal. Will use it for new session`);
+          newApp = localFile;
+          shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));
+          downloadIsNeaded = false;
+        } else {
+          logger.info(`[MCLOUD] Neither local version of app nor .lock file was found. Will download app from remote URL.`);
+          downloadIsNeaded = true;
+        }
+      } else {
+        logger.info(`[MCLOUD] Local apps folder is not defined via environment properties, hence skipping this logic`);
+      }
+      if(downloadIsNeaded) {
+      
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] Local version of app was not found. Hence using default Appium logic for downloading`);
+          const sharedFolderPath = await getSharedFolderForAppUrl(app);
+          logger.info(`[MCLOUD] Folder for local shared apps: ${sharedFolderPath}`);
+          await fs.close(await fs.open(lockFile, 'w'));
+        }
+
+        try {
       const cachedPath = getCachedApplicationPath(app, remoteAppProps);
       if (cachedPath) {
         if (await fs.exists(cachedPath)) {
@@ -220,6 +300,20 @@ async function configureApp (app, supportedAppExtensions) {
         suffix: '',
       });
       newApp = await downloadApp(newApp, targetPath);
+
+      // ***** Custom logic for copying of downloaded app to static location *****
+      if(localAppsFolder != undefined) {
+        logger.info(`[MCLOUD] New app path: ${newApp}`);
+        await fs.copyFile(newApp, localFile);
+      }
+      }
+      finally {
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] Going to remove lock file ${lockFile}`)
+          await fs.unlink(lockFile);
+        }
+      }
+      }
     } else if (await fs.exists(newApp)) {
       // Use the local app
       logger.info(`Using local app '${newApp}'`);
@@ -240,7 +334,7 @@ async function configureApp (app, supportedAppExtensions) {
       if (APPLICATIONS_CACHE.has(app) && archiveHash === APPLICATIONS_CACHE.get(app).hash) {
         const {fullPath} = APPLICATIONS_CACHE.get(app);
         if (await fs.exists(fullPath)) {
-          if (archivePath !== app) {
+          if (archivePath !== app && localAppsFolder === undefined) {
             await fs.rimraf(archivePath);
           }
           logger.info(`Will reuse previously cached application at '${fullPath}'`);
@@ -253,7 +347,7 @@ async function configureApp (app, supportedAppExtensions) {
       try {
         newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);
       } finally {
-        if (newApp !== archivePath && archivePath !== app) {
+        if (newApp !== archivePath && archivePath !== app && localAppsFolder === undefined) {
           await fs.rimraf(archivePath);
         }
       }
diff --git a/lib/protocol/protocol.js b/lib/protocol/protocol.js
index fd457dc..361731b 100644
--- a/lib/protocol/protocol.js
+++ b/lib/protocol/protocol.js
@@ -357,6 +357,9 @@ function buildHandler (app, method, path, spec, driver, isSessCmd) {
         SESSIONS_CACHE.resetLogger(req.params.sessionId);
       }
     } catch (err) {
+      // PATCH #2 <appium>/node_modules/appium/node_modules/appium-base-driver/build/lib/protocol/protocol.js to return to carina "DEBUG info" about problematic step
+      err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+
       // if anything goes wrong, figure out what our response should be
       // based on the type of error that we encountered
       let actualErr = err;
diff --git a/lib/basedriver/mcloud-utils.js b/lib/basedriver/mcloud-utils.js
new file mode 100644
index 0000000..273112a
--- /dev/null
+++ b/lib/basedriver/mcloud-utils.js
@@ -0,0 +1,79 @@
+import fs from 'appium-support/build/lib/fs';
+import nodePath from 'path';
+import axios from 'axios';
+import path from 'path';
+import logger from './logger';
+import { exec } from 'child_process';
+
+async function getLocalAppsFolder() {
+    return process.env.APPIUM_APPS_DIR;
+}
+
+async function getSharedFolderForAppUrl(url) {
+    const sub = await getLocalFileForAppUrl(url);
+
+    const lastSlashInd = sub.lastIndexOf(path.sep);
+    var targetPath;
+    if(lastSlashInd != -1) {
+        targetPath = sub.substring(0, lastSlashInd);
+    } else {
+        targetPath = '';
+    }
+
+    logger.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`)
+    const folderExists = await fs.exists(targetPath);
+    if(!folderExists)
+        await fs.mkdir(targetPath, {recursive : true});
+  
+    return targetPath;
+}
+
+async function getLocalFileForAppUrl(url) {
+    var sub = url.substring(url.indexOf('//') + 2)
+    sub = sub.substring(sub.indexOf('/'));
+    if(sub.includes('?')) {
+        sub = sub.substring(0, sub.indexOf('?'));
+    }
+    sub = sub.replace(/\//g, path.sep);
+
+    const targetPath = nodePath.join(await getLocalAppsFolder(), sub);
+    logger.info(`[MCLOUD] Target path [getLocalFileForAppUrl]: ${targetPath}`)
+    return targetPath;
+}
+
+async function getFileContentLength(remoteUrl) {
+    const timeout = 5000;
+    const requestOpts = {
+        url: remoteUrl,
+        responseType: 'stream',
+        timeout,
+    };
+
+    try {
+        const {
+          headers: responseHeaders,
+        } = await axios(requestOpts);
+        const responseLength = parseInt(responseHeaders['content-length'], 10);
+        logger.debug(`[MCLOUD] CONTENT-LENGTH for the file: ${responseLength}`);
+        return responseLength;
+    } catch (err) {
+        throw new Error(`[MCLOUD] Cannot get file content-length from ${remoteUrl}: ${err.message}`);
+    }
+}
+
+function executeShell(shellCommand, description) {
+    exec(shellCommand, (error, stdout, stderr) => {
+        if (error) {
+            logger.info(`[MCLOUD] ${description} error: ${error.message}`);
+            return;
+        }
+        if (stderr) {
+            logger.info(`[MCLOUD] ${description} stderr: ${stderr}`);
+            return;
+        }
+        logger.info(`[MCLOUD] ${description} command was successfully executed`);
+      });
+}
+
+
+module.exports = { getLocalAppsFolder, getSharedFolderForAppUrl, getLocalFileForAppUrl, getFileContentLength, executeShell }
\ No newline at end of file
